# Курсова робота

## Автор

Молчанов Михайло Валерійович

## Тема

Термінальний месенджер

## Зміст

- [Курсова робота](#курсова-робота)
  - [Автор](#автор)
  - [Тема](#тема)
  - [Зміст](#зміст)
  - [План виконання](#план-виконання)
  - [Аналітичний огляд літератури](#аналітичний-огляд-літератури)
    - [1. **Book of Rust**](#1-book-of-rust)
    - [2. **gRPC**](#2-grpc)
    - [3. **RabbitMQ**](#3-rabbitmq)
    - [4. **Kubernetes**](#4-kubernetes)
    - [5. **Azure**](#5-azure)
    - [6. **Docker**](#6-docker)
    - [7. **Redux**](#7-redux)
    - [8. **Auth0**](#8-auth0)
    - [9. **Design Patterns (Gang of Four)**](#9-design-patterns-gang-of-four)
    - [10. **PostgreSQL**](#10-postgresql)
    - [Аналіз](#аналіз)
  - [Діаграма Варіантів Використання для Месенджера](#діаграма-варіантів-використання-для-месенджера)
    - [Вступ](#вступ)
    - [Діаграма варіантів використання для месенджера (Рисунок 1)](#діаграма-варіантів-використання-для-месенджера-рисунок-1)
    - [Діаграма варіантів використання для авторизації (Рисунок 2)](#діаграма-варіантів-використання-для-авторизації-рисунок-2)
  - [Діаграми Класів](#діаграми-класів)
    - [Worker](#worker)
      - [Вступ](#вступ-1)
      - [Опис Компонентів Діаграми](#опис-компонентів-діаграми)
      - [Зв'язки між Класами](#звязки-між-класами)
      - [Функціональність Воркера](#функціональність-воркера)
    - [Server](#server)
      - [Вступ](#вступ-2)
      - [Опис Компонентів Діаграми](#опис-компонентів-діаграми-1)
      - [Основна Функціональність](#основна-функціональність)
      - [Зв'язки між Класами](#звязки-між-класами-1)
    - [Клієнт](#клієнт)
      - [Вступ](#вступ-3)
      - [Опис Компонентів Діаграми](#опис-компонентів-діаграми-2)
      - [Архітектура та Взаємодія](#архітектура-та-взаємодія)
      - [Важливість Діаграми Класів](#важливість-діаграми-класів)
      - [Переосмислення Підходу Redux](#переосмислення-підходу-redux)
        - [Вступ](#вступ-4)
        - [Опис Змін](#опис-змін)
        - [Переваги](#переваги)
  - [Діаграма Розгортання](#діаграма-розгортання)
    - [Вступ](#вступ-5)
    - [Опис Компонентів Діаграми](#опис-компонентів-діаграми-3)
    - [Особливості Розгортання](#особливості-розгортання)
    - [Важливість Діаграми Розгортання](#важливість-діаграми-розгортання)
  - [Діаграма Послідовностей](#діаграма-послідовностей)
    - [Прості варіанти](#прості-варіанти)
      - [Вступ](#вступ-6)
      - [Опис Процесу](#опис-процесу)
      - [Особливості Сценарію](#особливості-сценарію)
      - [Застосування Концепції](#застосування-концепції)
    - ["Відправлення Запрошення"](#відправлення-запрошення)
      - [Вступ](#вступ-7)
      - [Опис Процесу](#опис-процесу-1)
      - [Особливості Сценарію](#особливості-сценарію-1)
      - [Важливість Діаграми Послідовностей](#важливість-діаграми-послідовностей)
    - ["Відправлення Повідомлення"](#відправлення-повідомлення)
      - [Вступ](#вступ-8)
      - [Опис Процесу](#опис-процесу-2)
      - [Особливості Сценарію](#особливості-сценарію-2)
      - [Важливість Діаграми Послідовностей](#важливість-діаграми-послідовностей-1)
    - ["Прийняття Запрошення"](#прийняття-запрошення)
      - [Вступ](#вступ-9)
      - [Опис Процесу](#опис-процесу-3)
      - [Особливості Сценарію](#особливості-сценарію-3)
      - [Важливість Діаграми Послідовностей](#важливість-діаграми-послідовностей-2)

## План виконання

1. Створити простий docker compose для розгортання локально всіх компонент
2. auth(Auth0)
   1. Створити та налаштувати Auth0 tenant
   2. Створити інтерфейс на клієнті
   3. Створити таблицю в базі даних для користувачів
   4. Створити gRPC endpoint на сервері
3. Користувацький інтерфейс
   1. Перевірити що ідея працює та створити модуль для "redux" в клієнті
   2. Створити state клієнту
   3. Окреслити всі компоненти клієнту
   4. Підключити action до натискань клавіш
   5. Під'єднати їх до простих Reducer-ів
4. Чати
   1. Створити таблиці в базі даних для чатів
   2. Створити endpoint на сервері для чатів
   3. Створити клієнта для цих endpoint-ів
   4. Написати Reducer та Actions для чатів
5. Пошук користувачів
   1. Створити endpoint на сервері для пошуку
   2. Створити клієнта на них
   3. Під'єднати автоматичні запити поки користувач пише
   4. Виводити результати
6. Запрошення
   1. Таблиці для запрошень
   2. endpoint для запрошень, але поки що без стріму
   3. Налаштувати ребіт
   4. Воркер для створення та прийому повідомлень
   5. Повідомлення назад що було відправлено
   6. Клієнта для запитів
   7. Під'єднати до інтерфейсу
7. Повідомлення
   1. Таблиці
   2. Ендпоінти
   3. Запис в бд воркером через ребіт
   4. Читання з ребіту повідомлень та відправка назад
   5. Клієнт
   6. До інтерфейсу його
8. Правильний прийом запрошень
   1. Змінити частину з повідомленнями, щоб слухати ще один чат при прийомі
   2. Надсилати в стрімі користувачу нові

## Аналітичний огляд літератури

### 1. **Book of Rust**

- **Джерело**: [Book of Rust](https://doc.rust-lang.org/book/)
- **Аналіз**:
  - **Опис**: Основний ресурс для вивчення мови програмування Rust. Вона охоплює всі ключові концепції мови.
  - **Необхідність**: Ця книга служить фундаментом для розуміння того, як писати ефективний і безпечний код на Rust, який використовується в проекті. На неї будуть посилання в місцях де треба пояснити чому саме було використано певну конструкцію, які була специфічна для Rust.

### 2. **gRPC**

- **Джерело**: [gRPC](https://grpc.io/)
- **Аналіз**:
  - **Опис**: gRPC - це система віддаленого виклику процедур, яка забезпечує ефективне двостороннє спілкування.
  - **Необхідність**: Проект використовує gRPC для спілкування між сервером та клієнтом, що робить це джерело критично важливим для розуміння принципів роботи.

### 3. **RabbitMQ**

- **Джерело**: [RabbitMQ](https://rabbitmq.com/)
- **Аналіз**:
  - **Опис**: RabbitMQ - це система обміну повідомленнями, яка забезпечує асинхронне спілкування в розподілених системах.
  - **Необхідність**: Важливий компонент для обміну інформацією між сервером та воркерам в архітектурі проекту. Це дозволяє розбивати серверну частину не маленькі шматки, які спілкуються тільки за допомогою цих повідомлень.

### 4. **Kubernetes**

- **Джерело**: [Kubernetes](https://kubernetes.io/)
- **Аналіз**:
  - **Опис**: Платформа для автоматизації розгортання, масштабування та управління контейнерізованими застосунками.
  - **Необхідність**: Для розгортання серверної частини проекту в облачному оточенні. Та ефективного використання ресурсів та підтримання робти в разі відключень певний реплік.

### 5. **Azure**

- **Джерело**: [Azure](https://learn.microsoft.com/en-us/azure/?product=popular)
- **Аналіз**:
  - **Опис**: Облачна платформа від Microsoft, яка надає різноманітні послуги для розробників.
  - **Необхідність**: Використовується для хостингу серверної частини проекту.

### 6. **Docker**

- **Джерело**: [Docker](https://www.docker.com/)
- **Аналіз**:
  - **Опис**: Платформа для розробки, доставки та запуску застосунків у контейнерах.
  - **Необхідність**: Для створення та управління контейнерами, в яких розгортається проект. Вони потім будуть запускатись.

### 7. **Redux**

- **Джерело**: [Redux](https://redux.js.org/)
- **Аналіз**:
  - **Опис**: Жорстка архітектурна структура для створення інтерактивних застосунків.
  - **Необхідність**: Інспірація для архітектури клієнтської частини проекту. Більшість принципів буде згадуватись в клієнті.

### 8. **Auth0**

- **Джерело**: [Auth0](https://auth0.com/docs)
- **Аналіз**:
  - **Опис**: Сервіс для аутентифікації та авторизації в застосунках.
  - **Необхідність**: Забезпечення безпечної аутентифікації користувачів у проекті.

### 9. **Design Patterns (Gang of Four)**

- **Джерело**: [Design Patterns](https://www.javier8a.com/itc/bd1/articulo.pdf)
- **Аналіз**:
  - **Опис**: Основна книга про шаблони проектування в ООП.
  - **Необхідність**: Для використання найкращих практик проектування при створенні архітектури проекту. Це просто Біблія розробника.

### 10. **PostgreSQL**

- **Джерело**: [PostgreSQL](https://www.postgresql.org/)
- **Аналіз**:
  - **Опис**: Один з найпопулярніших відкритих систем управління базами даних.
  - **Необхідність**: Зберігання та управління даними для проекту.

### Аналіз

Під час розробки програмного забезпечення виникає дуже багато питань, які стосуються вибору технологій, архітектури, шаблонів проектування та методів оптимізації. Забезпечити коректну, ефективну та безпечну роботу системи можливо лише на базі глибокого розуміння основних інструментів та платформ, які обрано для її реалізації. В цьому контексті, обрана література є вкрай актуальною для проекту.

"Book of Rust" служить незамінним посібником по мові програмування Rust, який лежить в основі розробки консольного чату. Знання принципів цієї мови є ключовим для забезпечення продуктивності та безпеки коду.

Сайт gRPC надає детальний огляд протоколу віддаленого виклику процедур, який є основою для комунікації між сервером та клієнтом. Ефективність цього спілкування безпосередньо впливає на продуктивність системи в цілому.

Використовуючи RabbitMQ для асинхронного обміну даними між сервером та воркерами, необхідно зрозуміти всі його особливості та нюанси, що вказано на офіційному веб-сайті.

Kubernetes та Azure відіграють ключову роль у розгортанні та управлінні серверною частиною проекту в облачному середовищі. Інтимне розуміння їхніх можливостей дозволить максимально оптимізувати процеси, пов'язані з роботою сервера.

Docker є основою контейнерізації застосунку, що спрощує його розгортання та масштабування. Розуміння принципів роботи Docker є ключовим для ефективної роботи з проектом.

Структурна організація клієнтської частини застосунку надихнута патерном Redux, тому знання його основ є важливим для оптимізації клієнтського досвіду.

Для забезпечення безпечної аутентифікації користувачів використовується сервіс Auth0. Інтеграція цього сервісу потребує глибокого розуміння його механізмів та особливостей.

Книга "Design Patterns" від Gang of Four є класичним посібником з шаблонів проектування в ООП. Її принципи допомагають створити стійку та гнучку архітектуру проекту.

Накінець, документація PostgreSQL дозволяє глибше зрозуміти особливості роботи з базою даних, що є необхідним для забезпечення надійного зберігання та обробки інформації в системі.

Загалом, ця література надає всі необхідні засади та інструменти для успішної реалізації т

а оптимізації програмного забезпечення на всіх етапах його життєвого циклу.

## Діаграма Варіантів Використання для Месенджера

### Вступ

Цей розділ описує діаграму варіантів використання для месенджера, розробленого як частина курсової роботи. Діаграма демонструє взаємодію користувачів з системою месенджера і охоплює основні функції, які вони можуть виконувати.

### Діаграма варіантів використання для месенджера (Рисунок 1)

![Рисунок 1 - Варіанти використання месенджера](../architecture/use-case/messenger.png)

Діаграма на Рисунку 1 показує взаємодію користувачів з месенджером. Головним актором є користувач (User), який взаємодіє з різними аспектами системи:

1. **Читання Повідомлень (Read Messages)**: Користувач може читати повідомлення в чат румах.
2. **Написання Повідомлень (Write Messages)**: Користувач має можливість відправляти повідомлення в чат руми.
3. **Створення Чат Руму (Create Chat Room)**: Користувач може створити новий чат рум.
4. **Запрошення Користувачів до Чат Руму (Invite Users to Chat Room)**: Користувач може запрошувати інших користувачів до чат руму.
5. **Вихід із Чат Руму (Leave Chat Room)**: Користувач може вийти з чат руму.
6. **Пошук Користувачів (Search Users)**: Користувачі можуть шукати інших користувачів для спілкування.
7. **Запрошення до Приватної Бесіди (Invite to Personal Conversation)**: Користувачі можуть запрошувати інших до приватного діалогу.
8. **Прийняття Запрошень (Accept Invites)**: Користувач може приймати запрошення від інших.
9. **Відхилення Запрошень (Reject Invites)**: Користувач також може відхиляти запрошення.
10. **Розпочати Відео і Аудіо Дзвінок (Start Video and Audio Call)**: Користувачі мають можливість розпочинати аудіо та відео дзвінки.

Ці функції забезпечують основу для спілкування користувачів у месенджері та дозволяють створювати інтерактивне спілкування між користувачами.

### Діаграма варіантів використання для авторизації (Рисунок 2)

![Рисунок 2 - Варіанти використання авторизації](../architecture/use-case/auth.png)

На діаграмі авторизаці (Рисунок 2) представлено основні варіанти використання, пов'язані з управлінням акаунтом користувача:

1. **Вхід в систему (Sign in)**: Користувач може ввійти в систему, використовуючи свої облікові дані.
2. **Вихід з системи (Sign out)**: Користувач може вийти з системи.
3. **Реєстрація в системі (Sign up)**: Нові користувачі можуть створювати акаунт для використання месенджера.

Ці функції забезпечують захист та конфіденційність даних користувачів, а також дозволяють їм контролювати доступ до своїх акаунтів.

## Діаграми Класів

### Worker

![Рисунок 3 - Діаграма класів воркера](../architecture/class/worker.svg)

#### Вступ

У цьому розділі описана діаграма класів для компоненту "Воркер" у розробленій системі месенджера. Воркер є допоміжним елементом системи, який відповідає за обробку повідомлень від RabbitMQ (або аналогічної системи обміну повідомленнями) та запис цих повідомлень у базу даних.

#### Опис Компонентів Діаграми

1. **`ChannelFactory` (інтерфейс)**:
   - Описує метод `create()`, який повертає об'єкт типу `Channel`.
   - Цей інтерфейс визначає загальний шаблон для створення каналів зв'язку.

2. **`ChannelFactoryImpl` (структура)**:
   - Реалізація інтерфейсу `ChannelFactory`.
   - Відповідає за конкретну реалізацію створення каналів.

3. **`Consumer_V` (інтерфейс)**:
   - Визначає метод `consume()`.
   - Цей інтерфейс призначений для обробки різних типів повідомлень.

4. **`InviteCreatedConsumer`, `InviteAcceptedConsumer`, `MessageConsumer` (структури)**:
   - Реалізації інтерфейсу `Consumer_V`.
   - Кожен з цих класів відповідає за обробку конкретного типу повідомлень: створення запрошення, прийняття запрошення та звичайне повідомлення відповідно.
   - Вони пов'язані з `ChannelFactory`, що дозволяє їм отримувати доступ до каналів для зчитування повідомлень.

5. **`Worker` (інтерфейс)**:
   - Описує метод `work()`, який повертає результат роботи.
   - Цей інтерфейс визначає загальний шаблон для роботи воркерів.

6. **`WorkerImpl` (структура)**:
   - Реалізація інтерфейсу `Worker`.
   - Відповідає за фактичну обробку повідомлень, отриманих від споживачів (`Consumer_V`).

#### Зв'язки між Класами

- Кожен конкретний споживач (`InviteCreatedConsumer`, `InviteAcceptedConsumer`, `MessageConsumer`) реалізує інтерфейс `Consumer_V` та використовує `ChannelFactory` для доступу до каналів.
- `WorkerImpl` використовує споживачів для отримання повідомлень і виконує обробку цих повідомлень.

#### Функціональність Воркера

Головна задача воркера - слухати повідомлення від системи обміну повідомленнями (наприклад, RabbitMQ) і записувати їх у базу даних. Він фокусується на трьох типах повідомлень: повідомленнях від користувачів, запрошеннях до чату та відповідях на запрошення. Це забезпечує, що система вчасно реагує на дії користувачів та оновлює стан чату відповідно до змін.

### Server

![Рисунок 4 - Діаграма класів серверу](../architecture/class/server.svg)

#### Вступ

Цей розділ описує діаграму класів для серверної частини месенджера, що надає gRPC сервіс для клієнтів. Діаграма включає різноманітні компоненти та інтерфейси, кожен з яких відіграє ключову роль у забезпеченні функціональності та взаємодії сервера з клієнтами та іншими компонентами системи.

#### Опис Компонентів Діаграми

1. **`CrabMessenger` (інтерфейс)**:
   - Центральний інтерфейс для gRPC сервісу, що надає основні методи для взаємодії з месенджером.
   - Включає методи для чату, отримання чатів, створення нових чатів, пошуку користувачів, управління запрошеннями та отримання потоку запрошень.

2. **`CrabMessengerImpl` (структура)**:
   - Реалізація інтерфейсу `CrabMessenger`.

3. **`Messenger`, `ChatService`, `InviteService`, `UserService` (інтерфейси)**:
   - Логічно пов'язані інтерфейси, які виконують певні групи функцій у месенджері.

4. **`MessengerImpl`, `ChatServiceImpl`, `InviteServiceImpl`, `UserServiceImpl` (структури)**:
   - Конкретні реалізації відповідних інтерфейсів.

5. **`Producer_V`, `MessageProducer`, `InviteCreatedProducer`, `InviteAcceptedProducer` (інтерфейси та структури)**:
   - Абстракції, які відповідають за виробництво (публікацію) повідомлень у RabbitMQ.

6. **`InviteConsumer`, `MessageConsumer`, `InviteAcceptedConsumer` (інтерфейси та структури)**:
   - Абстракції, які відповідають за споживання повідомлень з RabbitMQ.

7. **`ChannelFactory`, `ChannelFactoryImpl` (інтерфейс та структура)**:
   - Відповідають за створення каналів з'єднань з RabbitMQ.

8. **`ChatNotifier`, `ChatNotifierImpl` (інтерфейс та структура)**:
   - Призначені для сповіщення користувачів про нові повідомлення у чаті.

#### Основна Функціональність

- **gRPC Сервіс**: Центральний елемент сервера, що надає API для клієнтів. Всі запити та відповіді проходять через `CrabMessenger`.
- **Розділення Функціоналу**: Логіка сервера розділена на кілька сервісів (`Messenger`, `ChatService`, `InviteService`, `UserService`), кожен з яких спеціалізується на конкретному аспекті месенджера.
- **Реалізація

 RabbitMQ**: Сервер використовує RabbitMQ для обробки потокових даних, що дозволяє надсилати повідомлення та запрошення в реальному часі. Канали з'єднань створюються за допомогою `ChannelFactory`.

#### Зв'язки між Класами

- `CrabMessengerImpl` інтегрує різні сервіси, щоб надати єдиний інтерфейс для клієнтів.
- `Producer_V` та відповідні реалізації (`MessageProducer`, `InviteCreatedProducer`, `InviteAcceptedProducer`) забезпечують публікацію повідомлень у RabbitMQ.
- `Consumer` інтерфейси та їх реалізації обробляють вхідні повідомлення з RabbitMQ.

### Клієнт

![Рисунок - Редакс клієнта](../architecture/class/client_redux.svg)
![Стан клієнта](../architecture/class/client_state.svg)
![Утиліти клієнта](../architecture/class/client_tools.svg)

#### Вступ

Цей розділ надає детальний опис діаграми класів клієнтської частини месенджера. Клієнтська частина реалізує архітектуру, схожу на Redux з веб-розробки, що дозволяє ефективно управляти станом і взаємодією користувача з програмою.

#### Опис Компонентів Діаграми

1. **`AppState` (структура)**:
   - Основна структура, що представляє стан застосунку в цілому.
   - Включає підструктури для різних аспектів інтерфейсу користувача, таких як `MessengerState`, `InvitesState`, `SearchState` тощо.

2. **`Action` (enum)**:
   - Перелік дій, що користувач може виконувати.
   - Кожен варіант enum має свої поля, що дозволяють передавати специфічні дані для кожної дії.

3. **`Store` (інтерфейс) та `StoreImpl` (структура)**:
   - Центральна точка управління станом застосунку.
   - Відповідає за диспетчеризацію дій і зберігання поточного стану.

4. **`Reducer` (інтерфейс) та різні реалізації**:
   - Відповідають за зміну стану застосунку в відповідь на різні дії.
   - Кожен `Reducer` має свою специфічну область відповідальності, таку як редагування тексту, навігація по меню, завантаження чатів тощо.

5. **Інтерфейси для Спілкування з Сервером (`MessengerClient`, `InvitesClient`, `UsersClient`, `ChatsClient`)**:
   - Кожен інтерфейс визначає набір функцій для взаємодії з серверною частиною месенджера.

6. **`Renderer` (інтерфейс) та `RendererImpl` (структура)**:
   - Відповідають за відображення поточного стану застосунку в інтерфейсі користувача.

#### Архітектура та Взаємодія

- Ключовим елементом архітектури є `Store`, який зберігає `AppState` і координує дії за допомогою `Reducers`.
- `Actions` ініціюють зміни в стані застосунку, які обробляються відповідними `Reducers`.
- Клієнтські інтерфейси забезпечують взаємодію з сервером для реалізації основних функцій месенджера.
- `Renderer` оновлю

є візуальну частину застосунку, відображаючи зміни в стані.

#### Важливість Діаграми Класів

Діаграма класів для клієнтської частини месенджера надає цілісне розуміння структури та взаємодії компонентів у клієнтському застосунку. Вона важлива для розробки та налагодження інтерфейсу користувача та управління станом застосунку.

#### Переосмислення Підходу Redux

##### Вступ

Переосмислення класичної моделі Redux для клієнтського застосунку в моєму месенджері відкриває нові можливості для більш ефективного та гнучкого управління станом. Нова архітектура з вкладеними редукторами (reducers) і розширеною логікою обробки дій (actions) дозволяє більш точно реагувати на користувацькі взаємодії з урахуванням контексту застосунку.

##### Опис Змін

1. **Роль `Reducer`**:
   - В оригінальній концепції Redux, кожна дія (action) обробляється одним відповідним редуктором. Але у вашому підході один action може потенційно відповідати декільком редукторам.

2. **Використання `Condition`**:
   - У кожного редуктора був метод `condition`, який визначав, чи слід йому обробляти певний action на основі поточного стану (state). Однак, це було неефективно з точки зору продуктивності та створювало складнощі у коді.

3. **Введення Вкладених `Reducer`**:
   - Тепер система має ієрархічну структуру редукторів. На вершині ієрархії знаходиться `AppReducer`, який містить інші редуктори, такі як `LoginReducer`, `ChatReducer` тощо.
   - Кожен редуктор тепер може повертати один із трьох результатів: змінений стан, позначку про виконану асинхронну дію без зміни стану, або індикацію, що action не було оброблено.

4. **Логіка Обробки `Action`**:
   - Коли `AppReducer` отримує action, він перш за все перевіряє дії з високим пріоритетом, такі як обробка системних команд (наприклад, Ctrl+C).
   - Далі він визначає, який компонент застосунку є активним, і передає action відповідному редуктору.
   - Якщо дія не була оброблена, `AppReducer` передає її наступному редуктору в ієрархії, наприклад `TabReducer`, який може змінити обраний компонент користувача.

##### Переваги

- **Гнучкість та Точність**: Завдяки можливості обробляти одну дію різними редукторами в залежності від контексту, застосунок може точніше реагувати на дії користувача.
- **Підвищена Ефективність**: Зменшення навантаження на обробку стан

у за рахунок уникнення зайвих перевірок і викликів.

- **Краща Організація Коду**: Ієрархічна структура редукторів допомагає організувати код більш систематично, розділяючи відповідальності між різними компонентами застосунку.

## Діаграма Розгортання

### Вступ

Цей розділ описує діаграму розгортання для месенджера. Діаграма ілюструє фізичну структуру системи та розміщення основних компонентів, включаючи клієнтські та серверні частини, а також засоби зв'язку між ними.

![Рисунок - Діаграма розгортання](../architecture/deploy/deployment.png)

### Опис Компонентів Діаграми

1. **Клієнтський Комп'ютер (ClientPC)**:
   - Місце розгортання клієнтського застосунку.
   - Зв'язується з сервером через gRPC.

2. **Cloud (Хмарне Середовище)**:
   - Включає Kubernetes класер, який складається з вузлів (WorkerNodes).

3. **WorkerNode (Вузол Кластера)**:
   - Розміщення основних компонентів серверної частини: `Worker`, `Server`, `RabbitMQ`, `Postgres`.
   - Кожен вузол має свої екземпляри цих компонентів.

4. **Зв'язки Між Компонентами**:
   - **Server-Client**: Зв'язок через gRPC для обміну даними між сервером та клієнтом.
   - **Server-RabbitMQ**: Використання AMQP для зв'язку сервера з RabbitMQ.
   - **Server-Postgres**: Зв'язок через TCP/IP для взаємодії сервера з базою даних Postgres.
   - **Worker-RabbitMQ та Worker-Postgres**: Використання TCP/IP та AMQP для взаємодії воркера з RabbitMQ та Postgres.

### Особливості Розгортання

- **Kubernetes**: Забезпечує гнучке управління розгортанням, масштабуванням і забезпеченням високої доступності.
- **Реплікація та Балансування Навантаження**: Кожен WorkerNode містить репліки основних компонентів, а балансування навантаження розподіляє запити між цими репліками.
- **Ізоляція Воркера**: Worker не має прямого зв'язку з зовнішнім світом, взаємодіючи лише з іншими компонентами в межах кластера.

### Важливість Діаграми Розгортання

Ця діаграма є ключовою для розуміння фізичної структури застосунку та взаємодії між його компонентами. Вона допомагає у плануванні інфраструктури, забезпеченні надійності та масштабуванні системи.

## Діаграма Послідовностей

### Прості варіанти

#### Вступ

Ця діаграма послідовностей описує процес, за яким користувач отримує список чатів у месенджері. Цей сценарій відображає типову взаємодію між клієнтом, сервером та базою даних без використання RabbitMQ.

#### Опис Процесу

1. **Ініціювання Дії Користувачем**:
   - Користувач відкриває вкладку чатів у клієнтському застосунку.

2. **Запит від Клієнта до Сервера**:
   - Клієнт формує та надсилає запит `getUserChats` до сервера.

3. **Обробка Запиту Сервером**:
   - Сервер отримує запит і виконує запит до бази даних Postgres для отримання списку чатів.

4. **Відповідь від Бази Даних**:
   - Postgres обробляє запит та надсилає серверу список чатів.

5. **Передача Даних від Сервера до Клієнта**:
   - Сервер відправляє відповідь `getUserChats reply` з отриманим списком чатів назад до клієнта.

6. **Відображення Даних Користувачу**:
   - Клієнт обробляє отримані дані і відображає їх користувачу.

#### Особливості Сценарію

- **Прямий Запит до Бази Даних**: Сервер безпосередньо звертається до бази даних для отримання необхідних даних.
- **Відсутність RabbitMQ**: Для цього сценарію не використовується RabbitMQ, оскільки не потрібно оповіщати інших користувачів чи змінювати налаштування з'єднання.
- **Простота та Ефективність**: Цей процес є простим та ефективним для дій, які не вимагають миттєвого сповіщення інших користувачів або складних операцій зі станом.

#### Застосування Концепції

Аналогічний підхід може бути застосований для інших функцій, таких як `getChat`, `getUser`, `getMessages`, де потрібно просто зчитувати дані з бази без складної логіки взаємодії.

### "Відправлення Запрошення"

#### Вступ

Ця діаграма послідовностей демонструє процес відправлення запрошення від одного користувача до іншого в месенджері. Цей сценарій включає взаємодію між клієнтом, сервером, RabbitMQ, воркером та базою даних.

#### Опис Процесу

1. **Ініціювання Дії Користувачем (User1)**:
   - Користувач 1 відправляє запрошення через клієнтський застосунок (Client1).

2. **Запит від Клієнта до Сервера**:
   - Client1 відправляє запит `createInvite` на сервер.

3. **Передача Запиту через RabbitMQ**:
   - Сервер створює та відправляє **CreateInvite** повідомлення в RabbitMQ.

4. **Обробка Запиту Воркером**:
   - Воркер споживає **CreateInvite** повідомлення з RabbitMQ та зберігає запрошення в базі даних Postgres.

5. **Повідомлення про Успішне Збереження**:
   - Воркер відправляє **CreateInvite** reply повідомлення через RabbitMQ назад на сервер.

6. **Відповідь Сервера до Клієнта 1**:
   - Сервер отримує відповідь і надсилає підтвердження створення запрошення до Client1.

7. **Відправлення Повідомлення про Створене Запрошення**:
   - Воркер відправляє повідомлення **InviteCreated** в RabbitMQ.

8. **Повідомлення Користувачу 2 (Якщо в Мережі)**:
   - Якщо користувач 2 (User2) підключений, його клієнт (Client2) через сервер отримує повідомлення про нове запрошення.

9. **Показ Запрошення Користувачу 2**:
   - Клієнт 2 відображає нове запрошення користувачу 2.

#### Особливості Сценарію

- **Асинхронна Обробка**: Використання RabbitMQ та воркера для асинхронної обробки запиту.
- **Збереження Стану**: Важливі дані, такі як запрошення, зберігаються в базі даних Postgres.
- **Сповіщення Отримувача**: Підключені користувачі отримують сповіщення в реальному часі.

#### Важливість Діаграми Послідовностей

Ця діаграма послідовностей важлива для розуміння інтерактивних та асинхронних процесів у месенджері, особливо у контексті взаємодії

### "Відправлення Повідомлення"

#### Вступ

Ця діаграма послідовностей демонструє процес відправлення повідомлення від одного користувача іншим учасникам чату в месенджері. Вона включає взаємодію між клієнтами, сервером, RabbitMQ, воркером, та базою даних.

#### Опис Процесу

1. **Відправлення Повідомлення Користувачем 1 (User1)**:
   - Користувач 1 пише та відправляє повідомлення через клієнтський застосунок (Client1).

2. **Передача Повідомлення до Сервера**:
   - Client1 відправляє повідомлення через стрім на сервер.

3. **Обробка Повідомлення Сервером**:
   - Сервер отримує повідомлення та відправляє команду **CreateMessage** до RabbitMQ.

4. **Збереження Повідомлення Воркером**:
   - Воркер споживає команду **CreateMessage** з RabbitMQ та зберігає повідомлення в базі даних Postgres.

5. **Публікація Створеного Повідомлення**:
   - Воркер публікує повідомлення **MessageCreated** в спеціальний ексчендж для відповідного чату в RabbitMQ.

6. **Розповсюдження Повідомлення Сервером**:
   - Сервер отримує повідомлення **MessageCreated** з RabbitMQ та відправляє його через стрім до підключених клієнтів (Client2).

7. **Отримання та Відображення Повідомлення Користувачем 2 (User2)**:
   - Клієнт 2 відображає повідомлення "Hello everyone" для користувача 2.

#### Особливості Сценарію

- **Асинхронна Обробка та Розповсюдження**: Використання RabbitMQ для асинхронного розповсюдження повідомлення між учасниками чату.
- **Збереження Стану**: Важливі дані, такі як текст повідомлення, зберігаються в базі даних Postgres.
- **Миттєве Сповіщення Учасників Чату**: Учасники чату отримують повідомлення в реальному часі, що забезпечує ефективне спілкування.

#### Важливість Діаграми Послідовностей

Ця діаграма є ключовою для розуміння процесу відправлення та отримання повідомлень у месенджері, показуючи важливість асинхронної обробки та розповсюдження повідомлень для забезпечення неперервної комунікації між користувачами.

### "Прийняття Запрошення"

#### Вступ

Ця діаграма послідовностей висвітлює процес прийняття запрошення користувачем та його подальшого входу в новий чат. Цей процес включає взаємодію між клієнтом, сервером, RabbitMQ, воркером та базою даних, із акцентом на зміні потоку повідомлень клієнта.

#### Опис Процесу

1. **Рішення Користувача Приєднатися до Чату**:
   - Користувач приймає рішення приєднатися до чату та ініціює дію через клієнтський застосунок.

2. **Відправлення Відповіді на Запрошення**:
   - Клієнт надсилає відповідь на запрошення (InviteAnswer) на сервер.

3. **Обробка Запрошення Сервером**:
   - Сервер отримує відповідь та відправляє команду **AcceptInvite** до RabbitMQ.

4. **Видалення Запрошення та Додавання Чату Воркером**:
   - Воркер споживає команду **AcceptInvite** з RabbitMQ, видаляє запрошення з бази даних Postgres та додає користувача до чату.

5. **Публікація Повідомлення про Прийняте Запрошення**:
   - Воркер публікує повідомлення **InviteAccepted** в RabbitMQ.

6. **Оновлення Стану Сервера**:
   - Сервер отримує повідомлення **InviteAccepted**, додає нову чергу для прослуховування до потоку клієнта.

7. **Відправлення Підтвердження Клієнту**:
   - Сервер відправляє клієнту підтвердження, що запрошення прийняте.

8. **Завантаження Повідомлень та Оновлення Стану Клієнта**:
   - Клієнт завантажує повідомлення з нового чату та оновлює свій стан, видаляючи запрошення.

9. **Повідомлення Користувачеві про Успішне Приєднання**:
   - Клієнт повідомляє користувачеві про успішне приєднання до чату.

#### Особливості Сценарію

- **Динамічна Зміна Потоку Повідомлень**: Сервер динамічно змінює потік повідомлень клієнта, додаючи нову чергу для чату.
- **Асинхронна Обробка**: Використання RabbitMQ для асинхронної обробки запитів.
- **Безперебійне Приєднання до

 Чату**: Користувач автоматично приєднується до чату та починає отримувати повідомлення без затримок.

#### Важливість Діаграми Послідовностей

Ця діаграма послідовностей є важливою для розуміння процесу прийняття запрошень та інтеграції користувача у нові чати, показуючи важливість асинхронної обробки та ефективного управління станом користувачів.


> I can't show you this, but I did the server implementation. You can check it here: <https://michaelmolchanov.visualstudio.com/crab-messenger/_git/crab-messenger>
